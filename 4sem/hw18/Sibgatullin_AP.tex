\documentclass[a4paper, 14pt]{extreport}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian, english]{babel}
% \usepackage[left=2.5cm, right=1.5cm, vmargin=2.5cm]{geometry}
\usepackage{indentfirst}
\renewcommand*\contentsname{}

\title{\textbf{Отчет по циклу заданий \\"Создание базы данных"}}
\author{Сибгатуллин Артур, 208 учебная группа}
\date{14 Мая, 2020}



\begin{document}
	\maketitle
	\tableofcontents
	\pagebreak
	
	\section{Введение}
	 В курсе предмета "Работа на ЭВМ и программирование" перед нами была поставлена задача в поэтапной разработки СУБД\footnote{Здесь и далее СУБД - Система управления базами данных } на основе SQL\footnote{SQL - structured query language}-подобного языка запросов. В данном отчете представлены этапы разработки ПО\footnote{Здесь и далее ПО-программное обеспечение} под названием "ABCD\footnote{ABCD - Arthur's best clever DataBase}"
	 
	 \newpage
	 \section{Процесс разработки}
	 
	 \subsection{Поставленные задачи}
	 	\begin{enumerate}
	 		\item Разработать парсер для "языка\footnote{Стандарт языка описан в Приложении} запросов".
	 		\item Реализовать СУБД на языке C++. В качестве структур поиска и хранения использовать двунаправленный список. Количество полей и их тип таков: [Символьная\_строка\footnote{Здесь и далее - Имя}] [Целое\_число\_1\footnote{Здесь и далее - Телефон}] [Целое\_число\_2\footnote{Здесь и далее - Группа}] 
	 		\item Оптимизировать СУБД путем добавления индивидуальных структур поиска для каждого из полей\
 		\end{enumerate}
 	
	 \subsection{Этапы решения задач}
	 	\begin{enumerate}
				\item Был создан парсер для "языка запросов".
				\item Созданный парсер был объединен с поисковой структурой - двунаправленным списком, который в свою очередь являлся и контейнером записей в базе данных.
				\item Создана первая "оптимальная" поисковая структура для поля "Имя". Структура -- Красно-Черное Дерево. В качестве отношения порядка на множестве записей с данными полями были специальным образом перегружены операторы сравнения:
					\begin{verbatim}
					int operator> (const Record &x){
					    int flag = strcmp(Data->getName(),x.getName());
					    if(flag == 0){
					        if(Data->getPhone() == x.getPhone()){
					            return Data->getGroup() > x.getGroup();
					        }
					        else return Data->getPhone() > x.getPhone();
					    }
					    else return (flag > 0 ? 1 : 0);
					}
					\end{verbatim}
				\item Создана и интегрированна "оптимальная" поисковая структура для поля "Телефон". Структура -- Хэш-множество на основе массива АВЛ-деревьев. Хэш-функция сопоставляет записе из базы данных сумму цифр поля "Телефон" по заданному модулю. В качестве отношения порядка на множестве записей с данными полями были перегружены операторы сравнения:
					\begin{verbatim}
					int operator> (const Record &x){
					    if(Data->getPhone() == x.getPhone()){
					        int flag = strcmp(Data->getName(),x.getName());
					        if(flag == 0) return Data->getGroup() > x.getGroup();
					        else return (flag > 0 ? 1 : 0);
					    }
					    else return Data->getPhone() > x.getPhone();
					}
					\end{verbatim}
				\item В связи со специфичным набором записей на которых должно использоваться ПО ABCD (большое количество повторений по полю "Группа") поисковая структура отличалась по принципу поиска от других полей. Структура -- Красно-черное дерево, в элементах которого содержатся Хэш и Красно-Черное дерево, описанные выше. Отношением порядка выступал стандартный порядок на числовой прямой. 
				\\	Если в поисковом запросе присутствовало условие на "Группу", то сначала поиск происходил по ее поисковой структуре. Далее, при наличии условий на другие поля поиск происходит в структурах лежащих внутри данного элемент дерева.
				\\ На данном этапе появилась проблема связанная с тем, что при отсутствии в поисковом запросе условия на поле "Группа", необходимо совершить обход всего дерева для поиска элемента в каждой "подструктуре" элемента дерева.
				\item Финальный этап разработки. Была решена проблема описанная в предыдущем пункте. Теперь для поисковых запросов, где отсутствует условие на поле "Группа" созданы отдельные поисковые структуры из этапов 3, 4. Таким образом, способ хранения данных и поиска в нашем ПО выглядит так:
					\begin{verbatim}
					class DataBase{
					    List Container
					    Hash PhoneSearch
					    RBTree NameSearch
					    RBTree GroupSearch{ RBTree NameSearch; Hash PhoneSearch }
					}
					\end{verbatim}
				
		 	\end{enumerate}
	 	
	 	\newpage
	 	\section{Заключение}
	 	Таким образом, все поставленные задачи были выполнены. ПО ABCD собирается из исходных файлов командой make. На выходе получается исполнимый файл a.out. Запуск программы имеет вид: ./a.out database\_name.txt hash\_size. В дальнейшем планируется дополнить ПО "ABCD" сетевыми возможностями(СУБД по типу Клиент-Сервер).
	 	
	 	\newpage
	 	\section{Приложение}

	
	
		
\end{document}
